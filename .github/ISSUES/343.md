# implement DRY utility functionality to avoid copying module inputs and outputs to templates.

**ghost** commented *Nov 2, 2017*

It seems to me like the current standard practice of using a template(s) to combine modules into an instantiable piece of infrastructure requires a lot of boilerplate copy/pasting which is also potentially error prone.  It would be very cool to be able to include a 'modules' block in the terragrunt block of terraform.tfvars and then just refer to them in the templates in the modules repo.  This would cause terragrunt to pull the variables and outputs from the modules listed and re-generate them as template variables and outputs - using the variables as-is and rewriting the outputs to refer to the module outputs.  Something like this (note - this isn't fully fleshed out idea - just something that occurred to me while I was hiking this morning)

terraform.tfvars:
```
terragrunt = {
  remote_state {
    ...
  }

  modules {
    vpc  = "git::ssh://git@github.com/gruntwork-io/module-vpc.git//modules/vpc-mgmt?ref=v0.3.0"
    ecs_cluster = "git:ssh://git@github.com/gruntwork-io/modules-ecs.git//modules/ecs-cluster?ref=v0.3.0"
  }

  terraform {
    source = "git::ssh://git@github.com/terragrunt_modules.git//vpc?ref=vX.Y.Z"
  }
  include {
    path = "${find_in_parent_folders()}"
  }
}
```

in terragrunt_modules.git//vpc/main.tf:
```
terraform {
  backend "s3" {}
}

provider "aws" {
  region = "${var.aws_region}"
}

module "vpc-myenv" {
  source = "terragrunt://vpc?output_prefix=myenv"

  module_var = "${var.some_var}"
  next_module_var = "${var.next_var}-myenv"
}

module "vpc-otherenv" {
  source = "terragrunt://vpc?output_prefix=otherenv"

  different_var = "${var.different"}
  next_module_var = "${var.next_var}-otherenv"
  extra var = ["${var.some_list}"]
}

module "ecs" {
  source = "terragrunt://ecs_cluster"

  vpc_id = "${module.vpc-myenv.vpc_id}"
}
```
There would be a generated_outputs.tf:
```
output "myenv_vpc_id" {
  value = "${module.vpc-myenv.vpc_id"}
}
...

output "otherenv_vpc_id" {
  value = "${module.vpc-otherenv.vpc_id"}
}
...

output "cluster_id" {
  value = "${module.ecs.cluster_id}"
}
...
```

That would cause all the outputs generated by each module to be written into a generated_outputs.tf file with the name prefix (or suffix) specified in the URL passed to the source resolver. On the inputs side, the user can specify that they want the template to have the same inputs as the module, no inputs (if there are multiple instances and they can all use the same input vars, you only need inputs from one instance), or name-munged inputs (for multiple instances that want different values).  And then the module is actually configured as-normal, with module input values specified in the module block.

I would think that such a system could all but eliminate the need to copy inputs from modules and copy-modify the outputs from modules - a process that can be a little error prone when performed manually - easy to make copy/paste errors when vars have similar names.

Now I can declare the plugin source once, in the terraform.tfvars file, but I can use it differently in each instance, all without having to deal with writing inputs and outputs except where I want to specify template-specific inputs and outputs.  If you put the modules block in the outer terraform.tfvars file, it would even be possible to just refer to modules by name in templates and it wouldn't even be necessary to configure the source at the lower level since it would just inherit it from the outer file - giving you a single place from which to maintain the set of modules you use in your infrastructure AND their versions, so you can upgrade every instance of a particular module by updating the 'ref' query param in a single place, or maintain multiple versions by simply using multiple urls with different names.

I have no clue as to the complexity of implementing such a thing, but I get the sense that terraform is modular enough to accommodate it.  Most of the work would be in terragrunt, plus needing to implement a different source resolver for modules (or rewriting that block when it copies the file).  But it all seems doable from my VERY n00b perspective.  I can already tell how much typing I'm going to have to do without it...
<br />
***


**brikis98** commented *Nov 3, 2017*

This would be handy for simple cases, but for the vast majority of real-world cases, it wouldn't be of much help. That's because the most real-world cases include not only  a module or two, but also all sorts of wiring between the modules, `terraform_remote_state` data sources to read info from other modules, provider configuration, Terraform version configuration, and so on. 

Typical example:

```hcl
provider "aws" {
  # ... various configs
}

terraform {
  required_version = "> 0.10.0"
}

module "foo" {
  source = "..."

  some_param = "${data.terraform_remote_state.vpc.vpc_id}"
}

module "bar" {
  source = "..."

  some_param = "${module.foo.xxx}"
}

data "terraform_remote_state" "vpc" {
  # ... various configs
}
```

To be able to support all of that you need to write Terraform code. That does mean a lot of copy/pasted input and output variables, which I agree is a bit annoying, but it tends to be pretty quick and easy to do, and represents < 1% of the real work with setting up infra, Terraform code, etc.
***

**brikis98** commented *Mar 13, 2018*

Closing in favor of #418.
***

